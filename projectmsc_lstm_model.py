# -*- coding: utf-8 -*-
"""ProjectMSc_LSTM_model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qIy59P5PuVGiim4dW0u2CSrI6aOPVOTb
"""

#Importing Libraries:
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import datetime
from tensorflow.keras.models import Sequential # Building a sequential model
from tensorflow.keras.optimizers import Adam # this is the optimiser to use
from tensorflow.keras import layers # building a model that is built from many layers

#Loading Datasets for Various Stocks:

#prices = pd.read_csv('SPY.csv')
#prices = pd.read_csv('AMD.csv')
#prices = pd.read_csv('TSLA.csv')
#prices = pd.read_csv('BABA.csv')
#prices = pd.read_csv('META.csv')
#prices = pd.read_csv('MRNA.csv')
#prices = pd.read_csv('SHOP.csv')
#prices = pd.read_csv('ZM.csv')
#prices = pd.read_csv('GOOGL.csv')
#prices = pd.read_csv('NFLX.csv')
#prices = pd.read_csv('NKE.csv')
#prices = pd.read_csv('MCD.csv')
#prices = pd.read_csv('EXPE.csv')
prices = pd.read_csv('BA.csv')

prices

prices = prices[['Date', 'Close']]
prices

prices['Date']

#Changing data type to string
def str_Date(Date):
  split = Date.split('-')
  year, month, day = int(split[0]), int(split[1]), int(split[2])
  return datetime.datetime(year=year, month=month, day=day)

Official_Date = str_Date('1962-01-02')
Official_Date

prices

prices['Date'] = prices['Date'].apply(str_Date)
prices['Date']

prices.index = prices.pop('Date')
prices

#Official prices
plt.figure(figsize=(10,5))
Price_data = plt.plot(prices.index, prices['Close'])

# Convert into a supervised learning problem

def Conversion(data_points, Beginning_Point, End_Point, n=3):
  Start = str_Date(Beginning_Point)
  End  = str_Date(End_Point)

  Prediction_Date = Start
  
  all_dates  = []
  X, Y = [], []

  end_period = False
  while True:
    prices_subset_data = data_points.loc[:Prediction_Date].tail(n+1)
    
    if len(prices_subset_data) != n+1:
      print(f'Error: Window of size {n} is too large for date {Prediction_Date}')
      return

    values = prices_subset_data['Close'].to_numpy()
    x, y = values[:-1], values[-1]

    all_dates.append(Prediction_Date)
    X.append(x)
    Y.append(y)

    week_commencing = data_points.loc[Prediction_Date:Prediction_Date+datetime.timedelta(days=7)]
    upcoming_datetime_in_str = str(week_commencing.head(2).tail(1).index.values[0])
    upcoming_date = upcoming_datetime_in_str.split('T')[0]
    yyyy_mm_dd = upcoming_date.split('-')
    year, month, day = yyyy_mm_dd
    upcoming_day = datetime.datetime(day=int(day), month=int(month), year=int(year))
    
    if end_period:
      break
    
    Prediction_Date = upcoming_day

    if Prediction_Date == End:
      end_period = True
    
  new_prices = pd.DataFrame({})
  new_prices['Target Date'] = all_dates 
  
  X = np.array(X)
  for i in range(0, n):
    X[:, i]
    new_prices[f'Target-{n-i}'] = X[:, i]
  
  new_prices['Target'] = Y

  return new_prices

#Chooses which timeframe to train and predict the model
prices_data = Conversion(prices, 
                                '2017-10-15', 
                                '2020-03-20', 
                                n=3)
prices_data

#Convert into NumPy arrays to feed into a Tensor Flow model
#This function generates a list of all_dates , an input matrix X (3dimensional), and y being the output vector)
def prices_data_to_date_X_y(updated_data):
  df_as_np = updated_data.to_numpy()

  all_dates  = df_as_np[:, 0]
#[:0] gets the first column
  first_column = df_as_np[:, 1:-1]
  X = first_column.reshape((len(all_dates ), first_column.shape[1], 1))

  Y = df_as_np[:, -1]

  return all_dates, X.astype(np.float32), Y.astype(np.float32)

all_dates, X, y = prices_data_to_date_X_y(prices_data)

all_dates.shape, X.shape, y.shape

#Training LSTM model
first_80 = int(len(all_dates ) * .8)
first_90 = int(len(all_dates ) * .9)

#Training partion = First 80% of data
all_dates_training_data, xValues_training, yValues_training = all_dates[:first_80], X[:first_80], y[:first_80]

#Validation data is from 80% - 90%
#Test data is 90% onwards
all_dates_val, xValues_validation, yValues_validation = all_dates[first_80:first_90], X[first_80:first_90], y[first_80:first_90]
all_dates_test, X_test, yValues_test = all_dates[first_90:], X[first_90:], y[first_90:]

#plt.figure(figsize=(6,2))
plt.plot(all_dates_training_data, yValues_training)
plt.plot(all_dates_val, yValues_validation)
plt.plot(all_dates_test, yValues_test)
plt.title('Data Split')

plt.legend(['Training Values', 'Validation Values', 'Test Values'])

lstm_model = Sequential([layers.Input((3, 1)),
                    layers.LSTM(64), #the bigger this number is '64 for e.g.' the more neurons the LSTM model uses. The bigger the number the more complicated the lstm_model is and the more prone it is to overfitting
                    layers.Dense(32, activation='relu'),
                    layers.Dense(32, activation='relu'),
                    layers.Dense(1)])

lstm_model.compile(loss='mse', 
              optimizer=Adam(learning_rate=0.001),
              metrics=['mean_absolute_error'])

lstm_model.fit(xValues_training, yValues_training, validation_data=(xValues_validation, yValues_validation), epochs=100)

#Obtaining root mean squared error (RMSE)
#rmse_test = np.sqrt(np.mean(((X_test - yValues_test) ** 2)))
#rmse_train = np.sqrt(np.mean(((X_test - yValues_test) ** 2)))

#Trainingall_datesNo = len(all_dates_training_data)
#Trainingall_datesNo

Training_data_predictions = lstm_model.predict(xValues_training).flatten()
plt.figure(figsize=(10,6))

#Plotting training Predictions
plt.plot(all_dates_training_data, Training_data_predictions)

#Plotting trainining actual prices
plt.plot(all_dates_training_data, yValues_training)

plt.legend(['Training Predictions', 'Training Observations'])
plt.title('BA Training Data (Oct 2017 - Oct 2019)')

from sklearn.metrics import mean_squared_error

#Calculating MSE & RMSE Values
Train_MSE = str(mean_squared_error(Training_data_predictions, yValues_training))
Train_RMSE = str(np.sqrt(mean_squared_error(Training_data_predictions, yValues_training)))
print('Training MSE =', Train_MSE)
print('Training RMSE = ', Train_RMSE)

val_predictions = lstm_model.predict(xValues_validation).flatten()
plt.figure(figsize=(10,6))

plt.plot(all_dates_val, val_predictions)
plt.plot(all_dates_val, yValues_validation)
plt.legend(['Validation Predictions', 'Validation Observations'])
plt.title('BA Validation Data (Nov 2019 - Jan 2020)')

#Calculating MSE & RMSE Values
Val_MSE = str(mean_squared_error(val_predictions, yValues_validation))
Val_RMSE = str(np.sqrt(mean_squared_error(val_predictions, yValues_validation)))

print('Validation MSE =', Val_MSE)
print('Validation RMSE =', Val_RMSE)

from IPython.core.pylabtools import figsize
test_predictions = lstm_model.predict(X_test).flatten()
plt.figure(figsize=(10,6))

plt.plot(all_dates_test, test_predictions)
plt.plot(all_dates_test, yValues_test)
plt.legend(['Testing Predictions', 'Testing Observations'])
plt.title('BA Testing Data (Feb 2020 - May 2020)')

#Calculating MSE & RMSE Values
Test_MSE = str(mean_squared_error(test_predictions, yValues_test))
Test_RMSE = str(np.sqrt(mean_squared_error(test_predictions, yValues_test)))
print('Test MSE =', Test_MSE)
print('Test RMSE =', Test_RMSE)

plt.figure(figsize=(12,8))

#Comining plots together
plt.plot(all_dates_training_data, Training_data_predictions)
plt.plot(all_dates_training_data, yValues_training)
plt.plot(all_dates_val, val_predictions)
plt.plot(all_dates_val, yValues_validation)
plt.plot(all_dates_test, test_predictions)
plt.plot(all_dates_test, yValues_test)
plt.legend(['Training Predictions', 
            'Training Observations',
            'Validation Predictions', 
            'Validation Observations',
            'Testing Predictions', 
            'Testing Observations'])
plt.title('BA Training vs Validation vs Testing (Oct 2017 - Mar 2020)')

print('Training MSE =', Train_MSE)
print('Training RMSE =', Train_RMSE)

print('\n')

print('Validation MSE =', Val_MSE)
print('Validation RMSE =', Val_RMSE)

print('\n')

print('Test MSE =', Test_MSE)
print('Test RMSE =', Test_RMSE)